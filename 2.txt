import java.io.*;
import java.util.ArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class Main {

    public static void main(String[] args) {
        // Проверяем наличие аргумента
        if (args.length == 0) {
            System.out.println("Не указана рабочая директория!");
            return;
        }

        // Определяемся с путем до рабочей директории
        File workDir = new File(args[0]);
        if (!workDir.isDirectory()) {
            System.out.println("Указанный путь не является директорией!");
            return;
        }

        // Список файлов для обработки
        ArrayList<File> files = new ArrayList<>();
        // Выбираем только нужные файлы
        for (File file : workDir.listFiles()) {
            if (file.isFile() && file.getName().startsWith("in_") && file.getName().endsWith(".dat")) {
                files.add(file);
            }
        }

        // Создаем пул потоков
        ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());

        // Сумма результатов
        double sum = 0;

        // Обрабатываем каждый файл в отдельном потоке
        for (File file : files) {
            executor.submit(() -> {
                try {
                    // Читаем файл
                    BufferedReader reader = new BufferedReader(new FileReader(file));
                    int action = Integer.parseInt(reader.readLine());
                    String[] numbers = reader.readLine().split(" ");

                    double result = 0;
                    // Выполняем действие над числами
                    switch (action) {
                        case 1:
                            result = Double.parseDouble(numbers[0]) + Double.parseDouble(numbers[1]);
                            break;
                        case 2:
                            result = Double.parseDouble(numbers[0]) * Double.parseDouble(numbers[1]);
                            break;
                        case 3:
                            result = (Double.parseDouble(numbers[0]) * Double.parseDouble(numbers[0])) +
                                    (Double.parseDouble(numbers[1]) * Double.parseDouble(numbers[1]));
                            break;
                    }

                    // Добавляем результат к сумме
                    synchronized (Main.class) {
                        sum += result;
                    }

                    // Закрываем файл
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });
        }

        // Ждем завершения работы всех потоков
        executor.shutdown();
        try {
            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        try {
            // Записываем результат в файл
            File outFile = new File(workDir, "out.dat");
            BufferedWriter writer = new BufferedWriter(new FileWriter(outFile));
            writer.write(Double.toString(sum));
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}